

% %NOTE:
% % CHECKED WITH SLIDES: YES!
% % CHECKED WITH EXERCISES: NO -- TODO
% % MISSING: 2a not added, petri-nets for the API skipped

\section{Software Introduction}


\subsection{Real-Time Systems}

\begin{definition}[Worst-case execution time - WCET]
The upper bound on the execution times of all tasks statistically known.
\end{definition}

\begin{definition}[Best-Case execution time - BCET]
The lower bound on the execution times of all tasks statistically known.
\end{definition}


Hard to determine execution time

\begin{itemize}[noitemsep]
\item Use of caches, pipelines, branch prediction, speculation makes prediction impossible
\item Measurements: determine execution time directly by observing the execution or a simulation on a set of inputs - does not guarantee an upper bound to all executions!
\item Exhaustive execution in general is not possible!
\item Compute timing along the structure of a program: check dependencies of instructions and sum up all worst-case-times
\item In general not possible to compute execution time (halting problem)!
\end{itemize}


\subsection{Time-Triggered Systems}

Can be implemented as a set of methods which are called each after another. A timer is set to interrupt, when the period $P$ ends.

\subsubsection{Informations}
\begin{itemize}[noitemsep]
\item No interrupts except by timer
\item Interaction with environment through polling - can be a problem if they are too long! Split them up in shorter processes
\item Schedule computed off-line - complex algorithms can be used
\item Deterministic behavior at run-time
\item Inflexible, no adaption to environment
\end{itemize}

\subsection{Example - Simple periodic time-triggered Scheduler}

\begin{itemize}[noitemsep]
\item Timer interrupts regularly with period P
\item All processes have same period P
\item Properties:
		\begin{itemize}
		\item later processes $(T_2, T_3)$ have unpredictable times
		\item No problem with communication because static ordering and no parallelism 
		\end{itemize}
\end{itemize}

\begin{theorem}

$\sum_{ (k) } WCET(T_k) < P$

\end{theorem}


\subsection{Example - Time-triggered cyclic executive Scheduler}

\begin{itemize}[noitemsep]
\item Processes may have different periods
\item The period P is partitioned into frames of length $f$
\item Long processes must be partitioned into a sequence of small processes - must store the program state!
\end{itemize}


\subsubsection{Conditions}

\begin{itemize}[noitemsep]
\item A process executes at most once within a frame: $f \leq p(k) \forall k$
\item Period $P$ is least common multiple of all periods $p(k)$
\item Processes start and complete within a single frame: $f \geq WCET(k) \forall k$
\item Between release time and deadline of every task there is at least one frame boundary: $2f - gcd(p(k), f) \leq D(k) \forall k$

\end{itemize}


\subsubsection{Properties}
\begin{itemize}[noitemsep]
\item No RTOS needed
\item No context-switch overhead because there is no preemption
\item Just a few scheduling overhead $\rightarrow$ can use a cheap processor
\item Development of a time triggered cyclic executive scheduler normally harder due to off-line scheduling
\item Not flexible, if later on a new process is added - need to compute everything from beginning
\end{itemize}


\subsection{Event triggered Systems}

\begin{itemize}[noitemsep]
\item The schedule of processes is determined by the occurence of external interrupts
\item Dynamic and adaptive: there are possible problems with respect to timing - problem when using buffers or shared ressources!
\item Guarantees can be given either off-line or during run-time
\end{itemize}


\subsection{Example - Non-preemtive event triggerd scheduling}


\subsubsection{Principle}

\begin{itemize}[noitemsep]
\item To each event, there is accosicated a corresponding process that will be executed
\item Events are emitted by a) external interrupts and b) by processes themselves
\item Events are collected in a queue; depending on queueing discipline, an event is chosen for running
\item Processes can not be preemted
\end{itemize}

\subsubsection{Properties}

\begin{itemize}[noitemsep]
\item Communication simple; no parallelism - interrupts may cause problems with shared resources (for example the process queue)
\item Buffer overflow if too many events are generated by environment or processes
\item Long processes must be split into smaller ones since long running time may cause buffer overflow
\end{itemize}


\subsection{Example - Preemtive event triggered scheduling}

Similar to non-preemtive event triggered scheduling - but processes can be preempted by others!

\subsubsection{Stack Policy}

\begin{itemize}[noitemsep]
\item Use usual stack-based context mechanism of function calls
\item This implies a LIFO order of their instantiation - unknown waiting time for external events!
\item Shared resources must be protected: use semaphores 
\end{itemize}


\subsection{Petri Nets}
\begin{itemize}[noitemsep]
\item Semantics of the calls is expressed using Petri Nets
\item Bipartite graph consisting of places and transitions
\item Data and control are represented by moving tokens
\item Token are moved by transition according to rules: A transition can fire (is enabled) if there is at least one token in every input place. After firing, one token is removed form each input place and one is added to each output place.
\end{itemize}

\subsection{Process}

\begin{definition}[Process]
A process is a unique execution of a program. Several copies of a program may run simultaneously or at different times. The process has its own state and consists of register values, memory stack and instruction pointer.
\end{definition}

\begin{definition}[Activation record]
Copy of the process state: registers and local data structures
\end{definition}

\begin{definition}[Context switch]
Current CPU context goes out, new CPU context goes in
\end{definition}

\subsubsection{Co-operative Multitasking}

\begin{itemize}[noitemsep]
\item Each process allows a context switch at \texttt{cswitch()} call
\item Scheduler chooses which process to run next
\item Advantages: predictable where context switch occurs. Less errors of shared resources. 
\item Problems: Programming error can keep other threads out. Real-time behavior at risk if it takes too long before context switch allowed
\end{itemize}


\subsubsection{Preemtive Multitasking}
\begin{itemize}[noitemsep]
\item Most powerful form of multitasking - scheduler controls when context switches and determines what process runs next
\item Use of timers to call OS and switch contexts
\end{itemize}


\cleardoublepage